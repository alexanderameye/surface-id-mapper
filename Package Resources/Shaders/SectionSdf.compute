#pragma kernel Seed
#pragma kernel FillDistanceTransform
#pragma kernel Flood

int Width;
int Height;
float Channel;
RWTexture2D<float4> Source;
RWTexture2D<float4> Result;

Texture2D<float4> InputTexture;
int Step;

uint2 BoundIndex(uint2 i){
	return uint2(clamp(i.x,0,Width),clamp(i.y,0,Height));
}

void GetMinDistancePoint(float2 curPos,float3 tarInfo,inout float4 minInfo)
{
	// z channel is seed ID
	if(tarInfo.z > 0 ){
		float distance = dot(curPos - tarInfo.xy,curPos - tarInfo.xy);
		if(distance < minInfo.w){
			minInfo = float4( tarInfo, distance);
		}
	}
}

#define PIXEL_CENTER_OFFSET 0.5

[numthreads(8,8,1)]
void Seed (uint3 id : SV_DispatchThreadID)
{
	// Calculate texture coordinates.
	float2 uv = (float2)id.xy / float2(Width, Height);

	// distance is measured from center of pixel so offset is added here
	//float2 sample_position = id.xy + PIXEL_CENTER_OFFSET;

	// out-of-bounds check
	//if (any(sample_position >= float2(Width, Height)))
		//return;

	// Sample input texture.
	float4 mask = InputTexture[id.xy];
	mask = step(0.01, mask);

	float value = 0;
	switch ((uint)Channel) {
	case 0: value = mask.r;
		break;
	case 1: value = mask.g;
		break;
	case 2: value = mask.b;
		break;
	case 3: value = mask.a;
		break;
	default: break;
	}

	
	Source[id.xy] = float4(id.xy * value.x, value.x, 0);
}




[numthreads(8,8,1)]
void Flood (uint3 id : SV_DispatchThreadID)
{
	// seed position,seed ID and distance with seed
	float4 minInfo = float4(0,0,0,999999);
	GetMinDistancePoint(id.xy,Source[id.xy].xyz,minInfo);
	GetMinDistancePoint(id.xy,Source[BoundIndex(id.xy + uint2(-Step,-Step))].xyz,minInfo);
	GetMinDistancePoint(id.xy,Source[BoundIndex(id.xy + uint2(-Step,Step))].xyz,minInfo);
	GetMinDistancePoint(id.xy,Source[BoundIndex(id.xy + uint2(-Step,0))].xyz,minInfo);
	GetMinDistancePoint(id.xy,Source[BoundIndex(id.xy + uint2(0,-Step))].xyz,minInfo);
	GetMinDistancePoint(id.xy,Source[BoundIndex(id.xy + uint2(0,Step))].xyz,minInfo);
	GetMinDistancePoint(id.xy,Source[BoundIndex(id.xy + uint2(Step,-Step))].xyz,minInfo);
	GetMinDistancePoint(id.xy,Source[BoundIndex(id.xy + uint2(Step,0))].xyz,minInfo);
	GetMinDistancePoint(id.xy,Source[BoundIndex(id.xy + uint2(Step,Step))].xyz,minInfo);
	Result[id.xy] = minInfo;
}


[numthreads(8,8,1)]
void FillDistanceTransform (uint3 id : SV_DispatchThreadID)
{
	float4 info = Source[id.xy];
	float intensity =  exp(-sqrt(info.w)*0.1);
	Result[id.xy] = float4(intensity,intensity,intensity,1);
}